---
layout: post
title:  "hash map"
date:   2016-05-25 14:20:09 +0800
categories: program
tag: program
---
# map
- map提供一个很常用的功能，那就是提供key-value的存储和查找功能。例如，我要记录一个人名和相应的存储，而且随时增加，要快速查找和修改。如果要速度快，就需要把这些记录按照字母顺序排列，然后按照二分法查找。但是增加记录的时候同时需要保持记录有序，因此需要插入排序。考虑到效率，这就需要用到二叉树。讲下去会没完没了，如果你使用STL 的map容器，你可以非常方便的实现这个功能，而不用关心其细节。
- 效率很高，100万条记录，最多也只要20次的string.compare的比较，就能找到你要找的记录;200万条记录事，也只要用21次的比较。因为是二分法查找。
- 速度永远都满足不了现实的需求。如果有100万条记录，我需要频繁进行搜索时，**20次比较也会成为瓶颈**，要是能降到一次或者两次比较是否有可能？而且当记录数到200万的时候也是一次或者两次的比较，是否有可能？而且还需要和map一样的方便使用。**用hash_map**

# hash_map

## hash_table原理
- hash_map基于hash table（哈希表）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价 **仅仅是消耗比较多的内存**。
- 使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得 **每个元素的关键字都与一个函数值（即数组下标，hash值）相对应**，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。
- 但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。总的来说，**“直接定址”与“解决冲突”是哈希表的两大特点**。

## hash_map原理
- 首先分配一大片内存，**形成许多桶**。是利用hash函数，对key进行映射到不同区域（桶）进行保存。   

  其**插入**过程是:
  1. 得到key
  2. 通过hash函数得到hash值
  3. 得到桶号(一般都为hash值对桶数求模)
  4. 存放key和value在桶内.

  其**取值**过程是:
  1. 得到key
  2. 通过hash函数得到hash值
  3. 得到桶号(一般都为hash值对桶数求模)
  4. 比较桶的内部元素是否与key相等，若都不相等，则没有找到
  5. 取出相等的记录的value。


- hash_map中直接地址用hash函数生成;解决冲突,用比较函数解决。

http://blog.csdn.net/gubenpeiyuan/article/details/9613979
